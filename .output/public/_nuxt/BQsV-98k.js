import{a7 as l,al as M,ab as z,ac as v,am as y,T as W,y as _}from"./BtqrO9Ir.js";import{p as u,i as R}from"./C5jMS97L.js";async function S(t,e){return await U(e).catch(i=>(console.error("Failed to get image meta for "+e,i+""),{width:0,height:0,ratio:0}))}async function U(t){if(typeof Image>"u")throw new TypeError("Image not supported");return new Promise((e,r)=>{const i=new Image;i.onload=()=>{const o={width:i.width,height:i.height,ratio:i.width/i.height};e(o)},i.onerror=o=>r(o),i.src=t})}function L(t){const e={options:t},r=(o,a={})=>$(e,o,a),i=(o,a={},s={})=>r(o,{...s,modifiers:y(a,s.modifiers||{})}).url;for(const o in t.presets)i[o]=(a,s,m)=>i(a,s,{...t.presets[o],...m});return i.options=t,i.getImage=r,i.getMeta=(o,a)=>b(e,o,a),i.getSizes=(o,a)=>E(e,o,a),e.$img=i,i}async function b(t,e,r){const i=$(t,e,{...r});return typeof i.getMeta=="function"?await i.getMeta():await S(t,i.url)}function $(t,e,r){var g,p;if(typeof e!="string"||e==="")throw new TypeError(`input must be a string (received ${typeof e}: ${JSON.stringify(e)})`);if(e.startsWith("data:"))return{url:e};const{provider:i,defaults:o}=j(t,r.provider||t.options.provider),a=x(t,r.preset);if(e=l(e)?e:M(e),!i.supportsAlias)for(const n in t.options.alias)e.startsWith(n)&&(e=z(t.options.alias[n],e.substr(n.length)));if(i.validateDomains&&l(e)){const n=v(e).host;if(!t.options.domains.find(f=>f===n))return{url:e}}const s=y(r,a,o);s.modifiers={...s.modifiers};const m=s.modifiers.format;(g=s.modifiers)!=null&&g.width&&(s.modifiers.width=u(s.modifiers.width)),(p=s.modifiers)!=null&&p.height&&(s.modifiers.height=u(s.modifiers.height));const c=i.getImage(e,s,t);return c.format=c.format||m||"",c}function j(t,e){const r=t.options.providers[e];if(!r)throw new Error("Unknown provider: "+e);return r}function x(t,e){if(!e)return{};if(!t.options.presets[e])throw new Error("Unknown preset: "+e);return t.options.presets[e]}function E(t,e,r){var g,p;const i=u((g=r.modifiers)==null?void 0:g.width),o=u((p=r.modifiers)==null?void 0:p.height),a=i&&o?o/i:0,s=[],m={};if(typeof r.sizes=="string")for(const n of r.sizes.split(/[\s,]+/).filter(f=>f)){const f=n.split(":");f.length===2&&(m[f[0].trim()]=f[1].trim())}else Object.assign(m,r.sizes);for(const n in m){const f=t.options.screens&&t.options.screens[n]||parseInt(n);let d=String(m[n]);const w=d.endsWith("vw");if(!w&&/^\d+$/.test(d)&&(d=d+"px"),!w&&!d.endsWith("px"))continue;let h=parseInt(d);if(!f||!h)continue;w&&(h=Math.round(h/100*f));const I=a?Math.round(h*a):o;s.push({width:h,size:d,screenMaxWidth:f,media:`(max-width: ${f}px)`,src:t.$img(e,{...r.modifiers,width:h,height:I},r)})}s.sort((n,f)=>n.screenMaxWidth-f.screenMaxWidth);const c=s[s.length-1];return c&&(c.media=""),{sizes:s.map(n=>`${n.media?n.media+" ":""}${n.size}`).join(", "),srcset:s.map(n=>`${n.src} ${n.width}w`).join(", "),src:c==null?void 0:c.src}}const A=()=>{const t=W(),e=_();return e.$img||e._img||(e._img=L({...R,nuxt:{baseURL:t.app.baseURL}}))};export{A as u};
